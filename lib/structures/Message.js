'use strict';

const Base = require("./Base");
const User = require("./User");
const Application = require("./Application");
const Mentions = require("./MessageMentions");
const { Routes } = require("../rest/Endpoints");

/**
 * Represents a Discord guild message 
 * @extends Base
 * @prop {snowflake} id ID of the message
 * @prop {snowflake} channelId id of the channel the message was sent in
 * @prop {snowflake} webhookId If the message is generated by a webhook, this is the webhook's id
 * @prop {number} createdTimestamp When this message was sent
 * @prop {number} editedTimestamp When this message was edited, or null if never
 * @prop {User} author The author of this message
 * @prop {atring} content Content of this message
 * @prop {object} embeds Any embedded content
 * @prop {object} attachments Any attached files
 * @prop {object} components Sent if the message contains components like buttons, action rows, or other interactive components
 * @prop {object} reactions Reactions of this message
 * @prop {mentions} mentions The mentions of this message (users, roles, channels...)
 * @prop {object} activity Sent with Rich Presence-related chat embeds
 * @prop {boolean} pinned Whether the message is pinned or not
 * @prop {ClientApplication} application Sent with Rich Presence-related chat embeds
 * @prop {snowflake} applicationId If the message is an Interaction or application-owned webhook, this is the id of the application
 * @prop {object} interaction Sent if the message is a response to an Interaction
 * @prop {object} reference The message that was answered
 * @prop {object} stickerItems Sent if the message contains stickers
 * @prop {Channel} thread The thread that was started from this message, includes thread member object
 * @prop {integer || string} nonce Used for validating a message was sent
 * @prop {integer} type The type of this message
 * @prop {integer} flags Message flags combined as bitfield
 * @prop {boolean} tss Whether this was a TSS message
 * @prop {integer} position A generally increasing integer (there may be gaps or duplicates) that represents the approximate position of the message in a thread, it can be used to estimate the relative position of the message in a thread in company with total_message_sent on parent thread
 */

class Message extends Base {
    constructor(client, data) {
        super(client);

        this._patch(data);
    }

    _patch(data) {
        this.id = data.id;

        if ('channel_id' in data) {
            this.channelId = data.channel_id;
        } else {
            this.channelId ??= null;
        }

        if ('webhook_id' in data) {
            this.webhookId = data.webhook_id;
        } else {
            this.webhookId ??= null;
        }

        if ('timestamp' in data) {
            this.createdTimestamp = Date.now(data.timestamp);
        } else {
            this.createdTimestamp = null;
        }

        if ('edited_timestamp' in data) {
            this.editedTimestamp = data.edited_timestamp;
        } else {
            this.editedTimestamp ??= null;
        }

        if ('author' in data) {
            this.author = new User(this.client, data.author);
        } else {
            this.author ??= null;
        }

        if ('content' in data) {
            this.content = data.content;
        } else {
            this.content ??= '';
        }

        if ('embeds' in data) {
            this.embeds = data.embeds;
        } else {
            this.embeds ??= [];
        }

        if ('attachments' in data) {
            this.attachments = data.attachments;
        } else {
            this.attachments ??= [];
        }

        if ('components' in data) {
            this.components = data.components;
        } else {
            this.components ??= [];
        }

        if ('reactions' in data) {
            this.reactions = data.reactions;
        } else {
            this.reactions ??= [];
        }

        this.mentions = new Mentions(this, data);

        if ('activity' in data) {
            this.activity = { 
                partyId: data.activity.party_id, 
                type: data.activity.type, 
            };
        } else {
            this.activity ??= null;
        }

        if ('pinned' in data) {
            this.pinned = data.pinned;
        } else {
            this.pinned ??= null;
        }

        if ('application' in data) {
            this.application = new Application(this.client, data.application);
        } else {
            this.application ??= null;
        }

        if ('application_id' in data) {
            this.applicationId = data.application_id;
        } else {
            this.applicationId ??= null;
        }

        if ('interaction' in data) {
            this.interaction = data.interaction;
        } else {
            this.interaction ??= null;
        }

        if ('message_reference' in data) {
            this.reference = data.message_reference;
        } else {
            this.reference ??= null;
        }

        if ('sticker_items' in data) {
            this.stickerItems = data.sticker_items;
        } else {
            this.stickerItems ??= null;
        }

        if ('thread' in data) {
            this.thread = data.thread;
        } else {
            this.thread ??= null;
        }

        if ('nonce' in data) {
            this.nonce = data.nonce;
        } else {
            this.nonce ??= null;
        }

        if ('type' in data) {
            this.type = data.type;
        } else {
            this.type ??= null;
        }

        if ('flags' in data) {
            this.flags = data.flags;
        } else {
            this.flags ??= null;
        }

        if ('tss' in data) {
            this.tss = data.tss;
        } else {
            this.tss ??= null;
        }

        if ('position' in data) {
            this.position = data.position;
        } else {
            this.position ??= null;
        }
    }

    /**
     * Reply this message
     * @returns {Promise<MessageObject>}
     * @param body The body of the message
     */
    reply(body = {}) {
        if (!('message_reference' in body) && (typeof(body.message_reference) !== 'object')) {
            body.message_reference = {
                message_id: this.id
            }
        }

        return this.client.createMessage(this.channelId, body);
    }

    /**
     * Delete this message
     * @returns {Promise<undefined>}
     */
    async delete() {
        await this.client.rest.delete(Routes.channelMessage(this.channelId, this.id), null, false);
    }
}


module.exports = Message;
